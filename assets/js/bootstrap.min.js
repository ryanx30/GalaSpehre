/*!
  * Bootstrap v4.5.2 (https://getbootstrap.com/)
  * Copyright 2011-2020 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */
!function (t, e) {
  "object" == typeof exports && "undefined" != typeof module ? e(exports, require("jquery"), require("popper.js")) : "function" == typeof define && define.amd ? define(["exports", "jquery", "popper.js"], e) : e((t = "undefined" != typeof globalThis ? globalThis : t || self).bootstrap = {}, t.jQuery, t.Popper)
}(this, (function (t, e, n) {
  "use strict";

  function i(t, e) {
    for (var n = 0; n < e.length; n++) {
      var i = e[n];
      i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(t, i.key, i)
    }
  }

  function o(t, e, n) {
    return e && i(t.prototype, e), n && i(t, n), t
  }

  function s() {
    return (s = Object.assign || function (t) {
      for (var e = 1; e < arguments.length; e++) {
        var n = arguments[e];
        for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i])
      }
      return t
    }).apply(this, arguments)
  }

  e = e && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e, n = n && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;

  function r(t) {
    var n = this, i = !1;
    return e(this).one(a.TRANSITION_END, (function () {
      i = !0
    })), setTimeout((function () {
      i || a.triggerTransitionEnd(n)
    }), t), this
  }

  var a = {
    TRANSITION_END: "bsTransitionEnd",
    getUID: function (t) {
      do {
        t += ~~(1e6 * Math.random())
      } while (document.getElementById(t));
      return t
    },
    getSelectorFromElement: function (t) {
      var e = t.getAttribute("data-target");
      if (!e || "#" === e) {
        var n = t.getAttribute("href");
        e = n && "#" !== n ? n.trim() : ""
      }
      try {
        return document.querySelector(e) ? e : null
      } catch (t) {
        return null
      }
    },
    getTransitionDurationFromElement: function (t) {
      if (!t) return 0;
      var n = e(t).css("transition-duration"), i = e(t).css("transition-delay"), o = parseFloat(n), s = parseFloat(i);
      return o || s ? (n = n.split(",")[0], i = i.split(",")[0], 1e3 * (parseFloat(n) + parseFloat(i))) : 0
    },
    reflow: function (t) {
      return t.offsetHeight
    },
    triggerTransitionEnd: function (t) {
      e(t).trigger("transitionend")
    },
    supportsTransitionEnd: function () {
      return Boolean("transitionend")
    },
    isElement: function (t) {
      return (t[0] || t).nodeType
    },
    typeCheckConfig: function (t, e, n) {
      for (var i in n) if (Object.prototype.hasOwnProperty.call(n, i)) {
        var o = n[i], s = e[i], r = s && a.isElement(s) ? "element" : null === (l = s) || "undefined" == typeof l ? "" + l : {}.toString.call(l).match(/\s([a-z]+)/i)[1].toLowerCase();
        if (!new RegExp(o).test(r)) throw new Error(t.toUpperCase() + ': Option "' + i + '" provided type "' + r + '" but expected type "' + o + '".')
      }
      var l
    },
    findShadowRoot: function (t) {
      if (!document.documentElement.attachShadow) return null;
      if ("function" == typeof t.getRootNode) {
        var e = t.getRootNode();
        return e instanceof ShadowRoot ? e : null
      }
      return t instanceof ShadowRoot ? t : t.parentNode ? a.findShadowRoot(t.parentNode) : null
    },
    jQueryDetection: function () {
      if ("undefined" == typeof e) throw new TypeError("Bootstrap's JavaScript requires jQuery. jQuery must be included before Bootstrap's JavaScript.");
      var t = e.fn.jquery.split(" ")[0].split(".");
      if (t[0] < 2 && t[1] < 9 || 1 === t[0] && 9 === t[1] && t[2] < 1 || t[0] >= 4) throw new Error("Bootstrap's JavaScript requires at least jQuery v1.9.1 but less than v4.0.0")
    }
  };

  a.jQueryDetection(), e.fn.emulateTransitionEnd = r, e.event.special[a.TRANSITION_END] = {
    bindType: "transitionend",
    delegateType: "transitionend",
    handle: function (t) {
      if (e(t.target).is(this)) return t.handleObj.handler.apply(this, arguments)
    }
  };

  var l = "alert", c = e.fn[l], h = function () {
    function t(t) {
      this._element = t
    }

    var n = t.prototype;
    return n.close = function (t) {
      var e = this._element;
      t && (e = this._getRootElement(t)), this._triggerCloseEvent(e).isDefaultPrevented() || this._removeElement(e)
    }, n.dispose = function () {
      e.removeData(this._element, "bs.alert"), this._element = null
    }, n._getRootElement = function (t) {
      var n = a.getSelectorFromElement(t), i = !1;
      return n && (i = document.querySelector(n)), i || (i = e(t).closest(".alert")[0]), i
    }, n._triggerCloseEvent = function (t) {
      var n = e.Event("close.bs.alert");
      return e(t).trigger(n), n
    }, n._removeElement = function (t) {
      var n = this;
      e(t).removeClass("show"), e(t).hasClass("fade") ? (i = a.getTransitionDurationFromElement(t), e(t).one(a.TRANSITION_END, (function (e) {
        return n._destroyElement(t, e)
      })).emulateTransitionEnd(i)) : this._destroyElement(t)
    }, n._destroyElement = function (t) {
      e(t).detach().trigger("closed.bs.alert").remove()
    }, t._jQueryInterface = function (n) {
      return this.each((function () {
        var i = e(this), o = i.data("bs.alert");
        o || (o = new t(this), i.data("bs.alert", o)), "close" === n && o[n](this)
      }))
    }, t._handleDismiss = function (t) {
      return function (e) {
        e && e.preventDefault(), t.close(this)
      }
    }, o(t, null, [{ key: "VERSION", get: function () {
      return "4.5.2"
    } }]), t
  }();

  e(document).on("click.bs.alert.data-api", '[data-dismiss="alert"]', h._handleDismiss(new h)), e.fn[l] = h._jQueryInterface, e.fn[l].Constructor = h, e.fn[l].noConflict = function () {
    return e.fn[l] = c, h._jQueryInterface
  };

  var u = e.fn.button, d = function () {
    function t(t) {
      this._element = t
    }

    var n = t.prototype;
    return n.toggle = function () {
      var t = !0, n = !0, i = e(this._element).closest('[data-toggle="buttons"]')[0];
      if (i) {
        var o = this._element.querySelector('input:not([type="hidden"])');
        if (o) {
          if ("radio" === o.type) if (o.checked && this._element.classList.contains("active")) t = !1; else {
            var s = i.querySelector(".active");
            s && e(s).removeClass("active")
          }
          t && ("checkbox" !== o.type && "radio" !== o.type || (o.checked = !this._element.classList.contains("active")), e(o).trigger("change")), o.focus(), n = !1
        }
      }
      this._element.hasAttribute("disabled") || this._element.classList.contains("disabled") || (t && e(this._element).toggleClass("active"), n && e(this._element).trigger("blur"))
    }, t._jQueryInterface = function (n) {
      return this.each((function () {
        var i = e(this), o = i.data("bs.button");
        o || (o = new t(this), i.data("bs.button", o)), "toggle" === n && o[n]()
      }))
    }, o(t, null, [{ key: "VERSION", get: function () {
      return "4.5.2"
    } }]), t
  }();

  e(document).on("click.bs.button.data-api", '[data-toggle^="button"]', function (t) {
    t.preventDefault();
    var n = t.target.closest(".btn");
    d._jQueryInterface.call(e(n), "toggle")
  }), e.fn.button = d._jQueryInterface, e.fn.button.Constructor = d, e.fn.button.noConflict = function () {
    return e.fn.button = u, d._jQueryInterface
  };
 
 
  const f = "carousel";
  const g = ".bs.carousel";
  const m = e.fn[f];
  
  const p = {
    interval: 5000,
    keyboard: true,
    slide: false,
    pause: "hover",
    wrap: true,
    touch: true
  };
  
  const _ = {
    interval: "(number|boolean)",
    keyboard: "boolean",
    slide: "(boolean|string)",
    pause: "(string|boolean)",
    wrap: "boolean",
    touch: "boolean"
  };
  
  const v = {
    TOUCH: "touch",
    PEN: "pen"
  };
  
  // Carousel class definition
  class Carousel {
    constructor(element, config) {
      this._items = null;
      this._interval = null;
      this._activeElement = null;
      this._isPaused = false;
      this._isSliding = false;
      this.touchTimeout = null;
      this.touchStartX = 0;
      this.touchDeltaX = 0;
      this._config = this._getConfig(config);
      this._element = element;
      this._indicatorsElement = this._element.querySelector(".carousel-indicators");
      this._touchSupported = "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0;
      this._pointerEvent = Boolean(window.PointerEvent || window.MSPointerEvent);
      this._addEventListeners();
    }
  
    next() {
      if (!this._isSliding) {
        this._slide("next");
      }
    }
  
    nextWhenVisible() {
      if (!document.hidden && e(this._element).is(":visible") && e(this._element).css("visibility") !== "hidden") {
        this.next();
      }
    }
  
    prev() {
      if (!this._isSliding) {
        this._slide("prev");
      }
    }
  
    pause(event) {
      if (!event) {
        this._isPaused = true;
      }
      if (this._element.querySelector(".carousel-item-next, .carousel-item-prev")) {
        a.triggerTransitionEnd(this._element);
        this.cycle(true);
      }
      clearInterval(this._interval);
      this._interval = null;
    }
  
    cycle(event) {
      if (!event) {
        this._isPaused = false;
      }
      if (this._interval) {
        clearInterval(this._interval);
        this._interval = null;
      }
      if (this._config.interval && !this._isPaused) {
        this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval);
      }
    }
  
    to(index) {
      const activeElement = this._element.querySelector(".active.carousel-item");
      const currentIndex = this._getItemIndex(activeElement);
  
      if (!(index > this._items.length - 1 || index < 0)) {
        if (this._isSliding) {
          e(this._element).one("slid.bs.carousel", () => this.to(index));
        } else {
          if (currentIndex === index) {
            return this.pause(), void this.cycle();
          }
  
          const direction = index > currentIndex ? "next" : "prev";
          this._slide(direction, this._items[index]);
        }
      }
    }
  
    dispose() {
      e(this._element).off(g);
      e.removeData(this._element, "bs.carousel");
      this._items = null;
      this._config = null;
      this._element = null;
      this._interval = null;
      this._isPaused = null;
      this._isSliding = null;
      this._activeElement = null;
      this._indicatorsElement = null;
    }
  
    _getConfig(config) {
      return (config = s({}, p, config)), a.typeCheckConfig(f, config, _), config;
    }
  
    _handleSwipe() {
      const absDeltaX = Math.abs(this.touchDeltaX);
      if (!(absDeltaX <= 40)) {
        const direction = absDeltaX / this.touchDeltaX;
        this.touchDeltaX = 0;
        direction > 0 ? this.prev() : this.next();
      }
    }
  
    _addEventListeners() {
      const t = this;
      if (this._config.keyboard) {
        e(this._element).on("keydown.bs.carousel", (event) => t._keydown(event));
      }
      if (this._config.pause === "hover") {
        e(this._element).on("mouseenter.bs.carousel", (event) => t.pause(event))
                        .on("mouseleave.bs.carousel", (event) => t.cycle(event));
      }
      if (this._config.touch) {
        this._addTouchEventListeners();
      }
    }
  
    _addTouchEventListeners() {
      const t = this;
      if (this._touchSupported) {
        const startEvent = (event) => {
          if (t._pointerEvent && v[event.originalEvent.pointerType.toUpperCase()]) {
            t.touchStartX = event.originalEvent.clientX;
          } else if (!t._pointerEvent) {
            t.touchStartX = event.originalEvent.touches[0].clientX;
          }
        };

        const endEvent = (event) => {
          if (t._pointerEvent && v[event.originalEvent.pointerType.toUpperCase()]) {
            t.touchDeltaX = event.originalEvent.clientX - t.touchStartX;
          }
          t._handleSwipe();
          if (t._config.pause === "hover") {
            t.pause();
            if (t.touchTimeout) {
              clearTimeout(t.touchTimeout);
            }
            t.touchTimeout = setTimeout(() => t.cycle(), 500 + t._config.interval);
          }
        };

        e(this._element.querySelectorAll(".carousel-item img")).on("dragstart.bs.carousel", (event) => event.preventDefault());

        if (this._pointerEvent) {
          e(this._element).on("pointerdown.bs.carousel", (event) => startEvent(event))
                          .on("pointerup.bs.carousel", (event) => endEvent(event));
          this._element.classList.add("pointer-event");
        } else {
          e(this._element).on("touchstart.bs.carousel", (event) => startEvent(event))
                          .on("touchend.bs.carousel", (event) => endEvent(event));
        }
      }
    }
  
    _keydown(event) {
      if (!/input|textarea/i.test(event.target.tagName)) {
        switch (event.which) {
          case 37:
            event.preventDefault();
            this.prev();
            break;
          case 39:
            event.preventDefault();
            this.next();
            break;
        }
      }
    }
  
    _getItemIndex(item) {
      return this._items = item && item.parentNode ? [].slice.call(item.parentNode.querySelectorAll(".carousel-item")) : [], this._items.indexOf(item);
    }
  
    _getItemByDirection(direction, item) {
      const isNext = direction === "next";
      const isPrev = direction === "prev";
      const index = this._getItemIndex(item);
      const lastIndex = this._items.length - 1;
  
      if ((isPrev && index === 0) || (isNext && index === lastIndex) && !this._config.wrap) {
        return item;
      }
  
      const newIndex = (index + (isPrev ? -1 : 1)) % this._items.length;
      return newIndex === -1 ? this._items[lastIndex] : this._items[newIndex];
    }
  
    _triggerSlideEvent(item, direction) {
      const index = this._getItemIndex(item);
      const activeIndex = this._getItemIndex(this._element.querySelector(".active.carousel-item"));
      const event = e.Event("slide.bs.carousel", {
        relatedTarget: item,
        direction: direction,
        from: activeIndex,
        to: index
      });
      e(this._element).trigger(event);
      return event;
    }
  
    _setActiveIndicatorElement(item) {
      if (this._indicatorsElement) {
        const activeIndicators = [].slice.call(this._indicatorsElement.querySelectorAll(".active"));
        e(activeIndicators).removeClass("active");
        const index = this._indicatorsElement.children[this._getItemIndex(item)];
        if (index) {
          e(index).addClass("active");
        }
      }
    }
  
    _slide(direction, nextItem) {
      let itemClass, nextClass, side;
      const activeItem = this._element.querySelector(".active.carousel-item");
      const currentIndex = this._getItemIndex(activeItem);
      const nextIndex = this._getItemIndex(nextItem);
      const shouldPause = Boolean(this._interval);
      
      if (direction === "next") {
        itemClass = "carousel-item-left";
        nextClass = "carousel-item-next";
        side = "left";
      } else {
        itemClass = "carousel-item-right";
        nextClass = "carousel-item-prev";
        side = "right";
      }
  
      if (nextItem && e(nextItem).hasClass("active")) {
        this._isSliding = false;
      } else if (!this._triggerSlideEvent(nextItem, side).isDefaultPrevented() && activeItem) {
        this._isSliding = true;
        if (shouldPause) {
          this.pause();
        }
        this._setActiveIndicatorElement(nextItem);
        e(nextItem).addClass(nextClass);
        a.reflow(nextItem);
        e(activeItem).addClass(itemClass);
        e(nextItem).addClass(itemClass);
  
        const complete = () => {
          e(nextItem).removeClass(nextClass + " " + itemClass).addClass("active");
          e(activeItem).removeClass("active " + itemClass);
          this._isSliding = false;
          setTimeout(() => {
            e(this._element).trigger("slid.bs.carousel");
          }, 0);
        };
  
        if (e(activeItem).hasClass("fade")) {
          e(activeItem).one("transitionend", complete).emulateTransitionEnd(600);
        } else {
          complete();
        }
  
        if (shouldPause) {
          this.cycle();
        }
      }
    }
  }
  
  e.fn[f] = function (config) {
    return this.each(function () {
      const data = e(this).data("bs.carousel");
      const _config = typeof config === "object" && config;
  
      if (!data) {
        const carousel = new Carousel(this, _config);
        e(this).data("bs.carousel", carousel);
      }
      
      if (typeof config === "string") {
        if (typeof data[config] === "undefined") {
          throw new TypeError(`No method named "${config}"`);
        }
        data[config]();
      }
    });
  };
  
  e.fn[f].Constructor = Carousel;
  e.fn[f].noConflict = function () {
    return e.fn[f] = m, this;
  };
  
  e(document).on("click.bs.carousel.data-api", "[data-bs-slide], [data-bs-slide-to]", function (event) {
    const target = e(this);
    const selector = a.getSelectorFromElement(this);
    const selectorTarget = e(selector);
    const config = selectorTarget.data("bs.carousel") ? "toggle" : target.data();
  
    if (target.is("[data-bs-slide-to]")) {
      config.interval = false;
    }
    
    selectorTarget[f](config);
    
    if (target.is("[data-bs-slide-to]")) {
      const index = target.data("bs-slide-to");
      selectorTarget[f]("to", index);
    }
    event.preventDefault();
  });
  
  e(window).on("load.bs.carousel.data-api", function () {
    const carousels = [].slice.call(document.querySelectorAll('[data-bs-ride="carousel"]'));
    for (const carousel of carousels) {
      e(carousel)[f](e(carousel).data());
    }
  });
  
  
// Define the dropdown component
var Dropdown = function (element) {
  this._element = element;
  this._menu = this._getMenuElement();
  this._isShown = false;
  this._initEvents();
};

// Initialize the dropdown events
Dropdown.prototype._initEvents = function () {
  var self = this;

  document.addEventListener('keydown', function (event) {
      self._dataApiKeydownHandler(event);
  });

  document.addEventListener('click', function (event) {
      self._clearMenus(event);
  });

  this._element.addEventListener('click', function (event) {
      event.preventDefault();
      event.stopPropagation();
      self.toggle();
  });

  this._menu.addEventListener('click', function (event) {
      event.stopPropagation();
  });
};

// Get the menu element
Dropdown.prototype._getMenuElement = function () {
  return document.querySelector('.dropdown-menu');
};

// Toggle the dropdown visibility
Dropdown.prototype.toggle = function () {
  if (this._isShown) {
      this.hide();
  } else {
      this.show();
  }
};

// Show the dropdown
Dropdown.prototype.show = function () {
  if (!this._isShown) {
      var event = new Event('show.bs.dropdown', { relatedTarget: this._element });
      this._element.dispatchEvent(event);

      if (this._isShown || event.defaultPrevented) return;

      this._isShown = true;
      this._menu.classList.add('show');
      this._element.setAttribute('aria-expanded', true);
  }
};

// Hide the dropdown
Dropdown.prototype.hide = function () {
  if (this._isShown) {
      var event = new Event('hide.bs.dropdown', { relatedTarget: this._element });
      this._element.dispatchEvent(event);

      if (event.defaultPrevented) return;

      this._isShown = false;
      this._menu.classList.remove('show');
      this._element.setAttribute('aria-expanded', false);
  }
};

// Clear menus on click
Dropdown.prototype._clearMenus = function (event) {
  if (!event.target.closest('.dropdown')) {
      this.hide();
  }
};

// Handle keydown events for accessibility
Dropdown.prototype._dataApiKeydownHandler = function (event) {
  var keyCode = event.which;
  var target = event.target;

  if (this._isShown) {
      if (keyCode === 27) { // ESC key
          this.hide();
      } else if (keyCode === 38 || keyCode === 40) { // UP/DOWN arrow keys
          this._handleArrowKeys(target, keyCode);
          event.preventDefault();
      }
  }
};

// Handle arrow key navigation
Dropdown.prototype._handleArrowKeys = function (target, keyCode) {
  var items = Array.from(this._menu.querySelectorAll('.dropdown-item:not(.disabled):visible'));
  var index = items.indexOf(target);

  if (keyCode === 38 && index > 0) { // UP arrow
      items[index - 1].focus();
  } else if (keyCode === 40 && index < items.length - 1) { // DOWN arrow
      items[index + 1].focus();
  }
};

// jQuery interface for dropdown
$.fn.dropdown = function () {
  return this.each(function () {
      new Dropdown(this);
  });
};

// Usage example
$(document).ready(function () {
  $('[data-toggle="dropdown"]').dropdown();
});

    
class Modal {
  constructor(element, config) {
      this._element = element;
      this._config = this._getConfig(config);
      this._dialog = element.querySelector('.modal-dialog');
      this._backdrop = null;
      this._isShown = false;
      this._isBodyOverflowing = false;
      this._ignoreBackdropClick = false;
      this._isTransitioning = false;
      this._scrollbarWidth = 0;
  }

  toggle(t) {
      return this._isShown ? this.hide() : this.show(t);
  }

  show(t) {
      if (!this._isShown && !this._isTransitioning) {
          if (this._element.classList.contains('fade')) {
              this._isTransitioning = true;
          }
          const event = new Event('show.bs.modal', { relatedTarget: t });
          this._element.dispatchEvent(event);

          if (this._isShown || event.defaultPrevented) return;

          this._isShown = true;
          this._checkScrollbar();
          this._setScrollbar();
          this._adjustDialog();
          this._setEscapeEvent();
          this._setResizeEvent();

          this._element.addEventListener('click.dismiss.bs.modal', (event) => this.hide(event));
          this._dialog.addEventListener('mousedown.dismiss.bs.modal', () => {
              this._element.addEventListener('mouseup.dismiss.bs.modal', (event) => {
                  if (event.target === this._element) {
                      this._ignoreBackdropClick = true;
                  }
              });
          });

          this._showBackdrop(() => this._showElement(t));
      }
  }

  hide(t) {
      if (t && t.preventDefault(), this._isShown && !this._isTransitioning) {
          const event = new Event('hide.bs.modal');
          this._element.dispatchEvent(event);

          if (!this._isShown || event.defaultPrevented) return;

          this._isShown = false;
          const isFade = this._element.classList.contains('fade');
          if (isFade) {
              this._isTransitioning = true;
          }

          this._setEscapeEvent();
          this._setResizeEvent();
          document.removeEventListener('focusin.bs.modal', this._focusHandler);
          this._element.classList.remove('show');

          if (isFade) {
              const transitionDuration = this._getTransitionDurationFromElement(this._element);
              this._element.addEventListener('transitionend', () => this._hideModal(), { once: true });
              this._element.style.transitionDuration = `${transitionDuration}ms`;
          } else {
              this._hideModal();
          }
      }
  }

  dispose() {
      [window, this._element, this._dialog].forEach((el) => {
          el.removeEventListener('.bs.modal');
      });
      document.removeEventListener('focusin.bs.modal', this._focusHandler);
      this._config = null;
      this._element = null;
      this._dialog = null;
      this._backdrop = null;
      this._isShown = null;
      this._isBodyOverflowing = null;
      this._ignoreBackdropClick = null;
      this._isTransitioning = null;
      this._scrollbarWidth = null;
  }

  handleUpdate() {
      this._adjustDialog();
  }

  _getConfig(config) {
      return { ...defaultConfig, ...config };
  }

  _showElement(t) {
      const isFade = this._element.classList.contains('fade');
      this._element.style.display = 'block';
      this._element.removeAttribute('aria-hidden');

      if (isFade) {
          this._element.offsetHeight; // trigger reflow
          this._element.classList.add('show');
      }

      this._enforceFocus();

      const event = new Event('shown.bs.modal', { relatedTarget: t });
      this._element.dispatchEvent(event);
  }

  _enforceFocus() {
      document.removeEventListener('focusin.bs.modal');
      document.addEventListener('focusin.bs.modal', (event) => {
          if (document !== event.target && this._element !== event.target &&
              !this._element.contains(event.target)) {
              this._element.focus();
          }
      });
  }

  _setEscapeEvent() {
      if (this._isShown) {
          this._element.addEventListener('keydown.dismiss.bs.modal', (event) => {
              if (this._config.keyboard && event.key === 'Escape') {
                  event.preventDefault();
                  this.hide();
              } else if (!this._config.keyboard && event.key === 'Escape') {
                  this._triggerBackdropTransition();
              }
          });
      } else {
          this._element.removeEventListener('keydown.dismiss.bs.modal');
      }
  }

  _setResizeEvent() {
      if (this._isShown) {
          window.addEventListener('resize.bs.modal', (event) => this.handleUpdate(event));
      } else {
          window.removeEventListener('resize.bs.modal');
      }
  }

  _hideModal() {
      this._element.style.display = 'none';
      this._element.setAttribute('aria-hidden', true);
      this._element.removeAttribute('aria-modal');
      this._element.removeAttribute('role');
      this._isTransitioning = false;

      this._showBackdrop(() => {
          document.body.classList.remove('modal-open');
          this._resetAdjustments();
          this._resetScrollbar();
          this._element.dispatchEvent(new Event('hidden.bs.modal'));
      });
  }

  _removeBackdrop() {
      if (this._backdrop) {
          this._backdrop.remove();
          this._backdrop = null;
      }
  }

  _showBackdrop(callback) {
      if (this._isShown && this._config.backdrop) {
          this._backdrop = document.createElement('div');
          this._backdrop.className = 'modal-backdrop';
          if (this._element.classList.contains('fade')) {
              this._backdrop.classList.add('fade');
          }
          document.body.appendChild(this._backdrop);

          this._element.addEventListener('click.dismiss.bs.modal', (event) => {
              this._ignoreBackdropClick ?
                  (this._ignoreBackdropClick = false) :
                  event.target === event.currentTarget && this._triggerBackdropTransition();
          });

          if (this._element.classList.contains('fade')) {
              this._backdrop.offsetHeight; // trigger reflow
              this._backdrop.classList.add('show');
          }

          if (!callback) return;

          const transitionDuration = this._getTransitionDurationFromElement(this._backdrop);
          this._backdrop.addEventListener('transitionend', callback, { once: true });
          this._backdrop.style.transitionDuration = `${transitionDuration}ms`;
      } else if (!this._isShown && this._backdrop) {
          this._backdrop.classList.remove('show');
          this._backdrop.addEventListener('transitionend', () => this._removeBackdrop(), { once: true });
      } else {
          callback && callback();
      }
  }

  _adjustDialog() {
      const isOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;
      if (!this._isBodyOverflowing && isOverflowing) {
          this._element.style.paddingLeft = `${this._scrollbarWidth}px`;
      } else if (this._isBodyOverflowing && !isOverflowing) {
          this._element.style.paddingRight = `${this._scrollbarWidth}px`;
      }
  }

  _resetAdjustments() {
      this._element.style.paddingLeft = '';
      this._element.style.paddingRight = '';
  }

  _checkScrollbar() {
      const rect = document.body.getBoundingClientRect();
      this._isBodyOverflowing = Math.round(rect.left + rect.right) < window.innerWidth;
      this._scrollbarWidth = this._getScrollbarWidth();
  }

  _setScrollbar() {
      if (this._isBodyOverflowing) {
          const fixedElements = [...document.querySelectorAll('.fixed-top, .fixed-bottom, .is-fixed, .sticky-top')];
          fixedElements.forEach((el) => {
              const padding = getComputedStyle(el).paddingRight;
              el.style.paddingRight = `${parseFloat(padding) + this._scrollbarWidth}px`;
          });
          document.body.style.paddingRight = `${parseFloat(getComputedStyle(document.body).paddingRight) + this._scrollbarWidth}px`;
          document.body.classList.add('modal-open');
      }
  }

  _resetScrollbar() {
      const fixedElements = [...document.querySelectorAll('.fixed-top, .fixed-bottom, .is-fixed, .sticky-top')];
      fixedElements.forEach((el) => {
          const padding = el.dataset.paddingRight || '';
          el.style.paddingRight = padding;
      });
      const bodyPadding = document.body.dataset.paddingRight || '';
      document.body.style.paddingRight = bodyPadding;
  }

  _getScrollbarWidth() {
      const scrollDiv = document.createElement('div');
      scrollDiv.className = 'modal-scrollbar-measure';
      document.body.appendChild(scrollDiv);
      const scrollbarWidth = scrollDiv.getBoundingClientRect().width - scrollDiv.clientWidth;
      document.body.removeChild(scrollDiv);
      return scrollbarWidth;
  }

  static jQueryInterface(config, relatedTarget) {
      return this.each(function () {
          const $this = $(this);
          let data = $this.data('bs.modal');
          const options = { ...defaultConfig, ...$this.data(), ...(typeof config === 'object' && config) };
          if (!data) {
              data = new Modal(this, options);
              $this.data('bs.modal', data);
          }
          if (typeof config === 'string') {
              data[config](relatedTarget);
          } else if (options.show) {
              data.show(relatedTarget);
          }
      });
  }
}

const defaultConfig = {
  backdrop: true,
  keyboard: true,
  show: true,
};

// Add event listener to jQuery
$.fn.modal = Modal.jQueryInterface;
$.fn.modal.Constructor = Modal;
$.fn.modal.noConflict = function () {
  $.fn.modal = jQueryInterface;
  return Modal.jQueryInterface;
};

    
const allowedAttributes = [
  "background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"
];

const whiteList = {
  "*": ["class", "dir", "id", "lang", "role", /^aria-[\w-]*$/i],
  a: ["target", "href", "title", "rel"],
  area: [],
  b: [],
  br: [],
  col: [],
  code: [],
  div: [],
  em: [],
  hr: [],
  h1: [],
  h2: [],
  h3: [],
  h4: [],
  h5: [],
  h6: [],
  i: [],
  img: ["src", "srcset", "alt", "title", "width", "height"],
  li: [],
  ol: [],
  p: [],
  pre: [],
  s: [],
  small: [],
  span: [],
  sub: [],
  sup: [],
  strong: [],
  u: [],
  ul: []
};

const urlPattern = /^(?:(?:https?|mailto|ftp|tel|file):|[^#&/:?]*(?:[#/?]|$))/gi;
const base64ImagePattern = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i;

function sanitizeHTML(html, whiteList, sanitizeFn) {
  if (html.length === 0) return html;

  if (sanitizeFn && typeof sanitizeFn === "function") {
      return sanitizeFn(html);
  }

  const parsedHTML = (new window.DOMParser()).parseFromString(html, "text/html");
  const tagNames = Object.keys(whiteList);
  const elements = Array.from(parsedHTML.body.querySelectorAll("*"));

  elements.forEach((element) => {
      const tagName = element.nodeName.toLowerCase();
      if (!tagNames.includes(tagName)) {
          element.parentNode.removeChild(element);
          return;
      }

      const attributes = Array.from(element.attributes);
      const allowedAttrs = [...(whiteList["*"] || []), ...(whiteList[tagName] || [])];

      attributes.forEach((attr) => {
          if (!isValidAttribute(attr, allowedAttrs)) {
              element.removeAttribute(attr.nodeName);
          }
      });
  });

  return parsedHTML.body.innerHTML;
}

function isValidAttribute(attr, allowedAttrs) {
  const attrName = attr.nodeName.toLowerCase();
  if (allowedAttrs.includes(attrName)) {
      return !allowedAttributes.includes(attrName) || 
             Boolean(attr.nodeValue.match(urlPattern) || attr.nodeValue.match(base64ImagePattern));
  }

  const regexes = allowedAttrs.filter(attr => attr instanceof RegExp);
  return regexes.some(regex => attrName.match(regex));
}

// Tooltip configuration
const tooltipDefaults = {
  animation: true,
  template: '<div class="tooltip" role="tooltip"><div class="arrow"></div><div class="tooltip-inner"></div></div>',
  trigger: "hover focus",
  title: "",
  delay: 0,
  html: false,
  selector: false,
  placement: "top",
  offset: 0,
  container: false,
  fallbackPlacement: "flip",
  boundary: "scrollParent",
  sanitize: true,
  sanitizeFn: null,
  whiteList: whiteList,
  popperConfig: null
};

// Tooltip events
const tooltipEvents = {
  HIDE: "hide.bs.tooltip",
  HIDDEN: "hidden.bs.tooltip",
  SHOW: "show.bs.tooltip",
  SHOWN: "shown.bs.tooltip",
  INSERTED: "inserted.bs.tooltip",
  CLICK: "click.bs.tooltip",
  FOCUSIN: "focusin.bs.tooltip",
  FOCUSOUT: "focusout.bs.tooltip",
  MOUSEENTER: "mouseenter.bs.tooltip",
  MOUSELEAVE: "mouseleave.bs.tooltip"
};

class Tooltip {
  constructor(element, config) {
      if (typeof Popper === "undefined") {
          throw new TypeError("Bootstrap's tooltips require Popper.js (https://popper.js.org/)");
      }
      this._isEnabled = true;
      this._timeout = 0;
      this._hoverState = "";
      this._activeTrigger = {};
      this._popper = null;
      this.element = element;
      this.config = this._getConfig(config);
      this.tip = null;
      this._setListeners();
  }

  enable() {
      this._isEnabled = true;
  }

  disable() {
      this._isEnabled = false;
  }

  toggleEnabled() {
      this._isEnabled = !this._isEnabled;
  }

  toggle(event) {
      if (this._isEnabled) {
          if (event) {
              const dataKey = Tooltip.DATA_KEY;
              let instance = $(event.currentTarget).data(dataKey);
              if (!instance) {
                  instance = new Tooltip(event.currentTarget, this._getDelegateConfig());
                  $(event.currentTarget).data(dataKey, instance);
              }
              instance._activeTrigger.click = !instance._activeTrigger.click;
              instance._isWithActiveTrigger() ? instance._enter(null, instance) : instance._leave(null, instance);
          } else {
              if ($(this.getTipElement()).hasClass("show")) {
                  return this._leave(null, this);
              }
              this._enter(null, this);
          }
      }
  }

  dispose() {
      clearTimeout(this._timeout);
      $(this.element).removeData(this.constructor.DATA_KEY);
      $(this.element).off(this.constructor.EVENT_KEY);
      $(this.element).closest(".modal").off("hide.bs.modal", this._hideModalHandler);
      if (this.tip) $(this.tip).remove();
      this._isEnabled = null;
      this._timeout = null;
      this._hoverState = null;
      this._activeTrigger = null;
      if (this._popper) {
          this._popper.destroy();
          this._popper = null;
      }
      this.element = null;
      this.config = null;
      this.tip = null;
  }

  show() {
      const self = this;
      if ($(this.element).css("display") === "none") {
          throw new Error("Please use show on visible elements");
      }
      
      const showEvent = $.Event(this.constructor.Event.SHOW);
      if (this.isWithContent() && this._isEnabled) {
          $(this.element).trigger(showEvent);
          const shadowRoot = findShadowRoot(this.element);
          const isVisible = $(shadowRoot || this.element.ownerDocument.documentElement).contains(this.element);
          if (showEvent.isDefaultPrevented() || !isVisible) return;

          const tipElement = this.getTipElement();
          const tipId = getUID(this.constructor.NAME);
          tipElement.setAttribute("id", tipId);
          this.element.setAttribute("aria-describedby", tipId);
          this.setContent();
          if (this.config.animation) $(tipElement).addClass("fade");

          const placement = typeof this.config.placement === "function" ?
              this.config.placement.call(this, tipElement, this.element) :
              this.config.placement;

          const attachment = this._getAttachment(placement);
          this.addAttachmentClass(attachment);

          const container = this._getContainer();
          $(tipElement).data(this.constructor.DATA_KEY, this);
          if (!$(this.element.ownerDocument.documentElement).contains(this.tip)) {
              $(tipElement).appendTo(container);
          }
          $(this.element).trigger(this.constructor.Event.INSERTED);
          this._popper = new Popper(this.element, tipElement, this._getPopperConfig(attachment));
          $(tipElement).addClass("show");
          if ("ontouchstart" in document.documentElement) {
              $(document.body).children().on("mouseover", null, $.noop);
          }

          const complete = function() {
              self.config.animation && self._fixTransition();
              const hoverState = self._hoverState;
              self._hoverState = null;
              $(self.element).trigger(self.constructor.Event.SHOWN);
              if (hoverState === "out") {
                  self._leave(null, self);
              }
          };

          if ($(this.tip).hasClass("fade")) {
              const transitionDuration = getTransitionDurationFromElement(this.tip);
              $(this.tip).one(TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
          } else {
              complete();
          }
      }
  }

  hide(callback) {
      const self = this;
      const tipElement = this.getTipElement();
      const hideEvent = $.Event(this.constructor.Event.HIDE);
      const complete = function() {
          if (self._hoverState !== "show" && tipElement.parentNode) {
              tipElement.parentNode.removeChild(tipElement);
          }
          self._cleanTipClass();
          self.element.removeAttribute("aria-describedby");
          $(self.element).trigger(self.constructor.Event.HIDDEN);
          if (self._popper) {
              self._popper.destroy();
          }
          callback && callback();
      };

      $(this.element).trigger(hideEvent);
      if (!hideEvent.isDefaultPrevented()) {
          $(tipElement).removeClass("show");
          if ("ontouchstart" in document.documentElement) {
              $(document.body).children().off("mouseover", null, $.noop);
          }
          this._activeTrigger.click = false;
          this._activeTrigger.focus = false;
          this._activeTrigger.hover = false;

          if ($(this.tip).hasClass("fade")) {
              const transitionDuration = getTransitionDurationFromElement(this.tip);
              $(tipElement).one(TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);
          } else {
              complete();
          }
          this._hoverState = "";
      }
  }

  setContent() {
      const tip = this.getTipElement();
      const title = this.getTitle();
      $(tip).find(".tooltip-inner").html(title);
  }

  getTitle() {
      const title = this.element.getAttribute("data-original-title") || (typeof this.config.title === "function" ? this.config.title.call(this.element) : this.config.title);
      return sanitizeHTML(title, this.config.whiteList, this.config.sanitizeFn) || "";
  }

  getTipElement() {
      if (!this.tip) {
          this.tip = $(this.config.template)[0];
      }
      return this.tip;
  }

  _getConfig(config) {
      config = {
          ...this.constructor.Default,
          ...$(this.element).data(),
          ...(typeof config === "object" ? config : {})
      };
      if (typeof config.delay === "number") {
          config.delay = {
              show: config.delay,
              hide: config.delay
          };
      }
      return config;
  }

  _setListeners() {
      const triggers = this.config.trigger.split(" ");
      triggers.forEach(trigger => {
          if (trigger === "click") {
              $(this.element).on("click." + this.constructor.EVENT_KEY, this.config.selector, event => this.toggle(event));
          } else if (trigger !== "manual") {
              const eventIn = trigger === "hover" ? "mouseenter" : "focusin";
              const eventOut = trigger === "hover" ? "mouseleave" : "focusout";

              $(this.element).on(eventIn + "." + this.constructor.EVENT_KEY, this.config.selector, event => this._enter(event))
                           .on(eventOut + "." + this.constructor.EVENT_KEY, this.config.selector, event => this._leave(event));
          }
      });
      $(this.element).closest(".modal").on("hide.bs.modal", () => this.hide());
  }

  _enter(event, context) {
      const self = this;
      const dataKey = Tooltip.DATA_KEY;

      if (!context) {
          context = $(event.currentTarget).data(dataKey);
      }

      if (context) {
          context._activeTrigger["focus"] = true;
      }

      if ($(this.tip).hasClass("show") || this._hoverState === "show") {
          this._hoverState = "show";
          return;
      }

      clearTimeout(this._timeout);
      this._hoverState = "show";

      if (!this.config.delay || !this.config.delay.show) {
          return this.show();
      }

      this._timeout = setTimeout(() => {
          if (this._hoverState === "show") {
              self.show();
          }
      }, this.config.delay.show);
  }

  _leave(event, context) {
      const self = this;
      const dataKey = Tooltip.DATA_KEY;

      if (!context) {
          context = $(event.currentTarget).data(dataKey);
      }

      if (context) {
          context._activeTrigger["focus"] = false;
      }

      if ($(this.tip).hasClass("show") || this._hoverState === "out") {
          this._hoverState = "out";
          return;
      }

      clearTimeout(this._timeout);
      this._hoverState = "out";

      if (!this.config.delay || !this.config.delay.hide) {
          return this.hide();
      }

      this._timeout = setTimeout(() => {
          if (self._hoverState === "out") {
              self.hide();
          }
      }, this.config.delay.hide);
  }

  _getContainer() {
      return this.config.container === false ? document.body : $(this.config.container);
  }

  _getAttachment(placement) {
      return {
          top: "bottom",
          bottom: "top",
          left: "right",
          right: "left"
      }[placement] || placement;
  }

  _getPopperConfig(attachment) {
      const popperConfig = {
          placement: attachment,
          modifiers: {
              offset: {
                  offset: this.config.offset
              },
              flip: {
                  behavior: this.config.fallbackPlacement
              },
              preventOverflow: {
                  boundariesElement: this.config.boundary
              },
              arrow: {
                  element: ".arrow"
              }
          }
      };
      return {
          ...popperConfig,
          ...this.config.popperConfig
      };
  }

  _cleanTipClass() {
      const tip = this.getTipElement();
      const tabClass = Object.keys(this.constructor.Default).map(k => `${k}-${this.config[k]}`).join(" ");
      if (tabClass) {
          $(tip).removeClass(tabClass);
      }
  }

  _fixTransition() {
      const tip = this.getTipElement();
      const isFade = $(tip).hasClass("fade");
      if (isFade) {
          tip.classList.remove("fade");
          void tip.offsetWidth; // trigger reflow
          tip.classList.add("fade");
      }
  }

  _isWithActiveTrigger() {
      return Object.values(this._activeTrigger).some(value => value);
  }

  static get Default() {
      return tooltipDefaults;
  }

  static get DATA_KEY() {
      return "bs.tooltip";
  }

  static get EVENT_KEY() {
      return "." + this.DATA_KEY;
  }

  static get Event() {
      return tooltipEvents;
  }
}

// Usage example
const tooltipTrigger = document.querySelector('.tooltip-trigger');
new Tooltip(tooltipTrigger, {
  title: "Your tooltip title",
  placement: "top"
});

    
this._hideModalHandler = function() {
  if (t.element) {
      t.hide();
  }
};

e(this.element).closest(".modal").on("hide.bs.modal", this._hideModalHandler);

if (this.config.selector) {
  this.config = s({}, this.config, { trigger: "manual", selector: "" });
} else {
  this._fixTitle();
}

i._fixTitle = function() {
  var titleType = typeof this.element.getAttribute("data-original-title");
  if (this.element.getAttribute("title") || titleType !== "string") {
      this.element.setAttribute("data-original-title", this.element.getAttribute("title") || "");
      this.element.setAttribute("title", "");
  }
};

i._enter = function(t, n) {
  var dataKey = this.constructor.DATA_KEY;
  n = n || e(t.currentTarget).data(dataKey);
  
  if (!n) {
      n = new this.constructor(t.currentTarget, this._getDelegateConfig());
      e(t.currentTarget).data(dataKey, n);
  }

  if (t) {
      n._activeTrigger["focusin" === t.type ? "focus" : "hover"] = true;
  }

  if (!e(n.getTipElement()).hasClass("show") && n._hoverState !== "show") {
      clearTimeout(n._timeout);
      n._hoverState = "show";

      if (n.config.delay && n.config.delay.show) {
          n._timeout = setTimeout(() => {
              if (n._hoverState === "show") {
                  n.show();
              }
          }, n.config.delay.show);
      } else {
          n.show();
      }
  }
};

i._leave = function(t, n) {
  var dataKey = this.constructor.DATA_KEY;
  n = n || e(t.currentTarget).data(dataKey);
  
  if (!n) {
      n = new this.constructor(t.currentTarget, this._getDelegateConfig());
      e(t.currentTarget).data(dataKey, n);
  }

  if (t) {
      n._activeTrigger["focusout" === t.type ? "focus" : "hover"] = false;
  }

  if (!n._isWithActiveTrigger()) {
      clearTimeout(n._timeout);
      n._hoverState = "out";

      if (n.config.delay && n.config.delay.hide) {
          n._timeout = setTimeout(() => {
              if (n._hoverState === "out") {
                  n.hide();
              }
          }, n.config.delay.hide);
      } else {
          n.hide();
      }
  }
};

i._isWithActiveTrigger = function() {
  return Object.values(this._activeTrigger).some(Boolean);
};

i._getConfig = function(t) {
  var n = e(this.element).data();
  Object.keys(n).forEach(function(key) {
      if (M.includes(key)) {
          delete n[key];
      }
  });

  t = s({}, this.constructor.Default, n, typeof t === "object" && t ? t : {});

  if (typeof t.delay === "number") {
      t.delay = { show: t.delay, hide: t.delay };
  }

  if (typeof t.title === "number") {
      t.title = t.title.toString();
  }

  if (typeof t.content === "number") {
      t.content = t.content.toString();
  }

  a.typeCheckConfig(B, t, this.constructor.DefaultType);

  if (t.sanitize) {
      t.template = Q(t.template, t.whiteList, t.sanitizeFn);
  }

  return t;
};

i._getDelegateConfig = function() {
  var t = {};
  if (this.config) {
      for (var key in this.config) {
          if (this.constructor.Default[key] !== this.config[key]) {
              t[key] = this.config[key];
          }
      }
  }
  return t;
};

i._cleanTipClass = function() {
  var t = e(this.getTipElement());
  var classList = t.attr("class").match(U);
  if (classList !== null && classList.length) {
      t.removeClass(classList.join(""));
  }
};

i._handlePopperPlacementChange = function(t) {
  this.tip = t.instance.popper;
  this._cleanTipClass();
  this.addAttachmentClass(this._getAttachment(t.placement));
};

i._fixTransition = function() {
  var t = this.getTipElement();
  var animation = this.config.animation;
  
  if (t.getAttribute("x-placement") === null) {
      e(t).removeClass("fade");
      this.config.animation = false;
      this.hide();
      this.show();
      this.config.animation = animation;
  }
};

t._jQueryInterface = function(n) {
  return this.each(function() {
      var i = e(this).data("bs.tooltip");
      var options = typeof n === "object" && n;

      if ((i || !/dispose|hide/.test(n)) && (!i && (i = new t(this, options), e(this).data("bs.tooltip", i)), typeof n === "string")) {
          if (typeof i[n] === "undefined") {
              throw new TypeError('No method named "' + n + '"');
          }
          i[n]();
      }
  });
};

o(t, null, [
  { key: "VERSION", get: function() { return "4.5.2"; } },
  { key: "Default", get: function() { return z; } },
  { key: "NAME", get: function() { return B; } },
  { key: "DATA_KEY", get: function() { return "bs.tooltip"; } },
  { key: "Event", get: function() { return K; } },
  { key: "EVENT_KEY", get: function() { return ".bs.tooltip"; } },
  { key: "DefaultType", get: function() { return W; } }
]);

e.fn[B] = X._jQueryInterface;
e.fn[B].Constructor = X;
e.fn[B].noConflict = function() {
  return e.fn[B] = H, X._jQueryInterface;
};

var Y = "popover",
  $ = e.fn[Y],
  J = new RegExp("(^|\\s)bs-popover\\S+", "g"),
  G = s({}, X.Default, {
      placement: "right",
      trigger: "click",
      content: "",
      template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>'
  }),
  Z = s({}, X.DefaultType, {
      content: "(string|element|function)"
  }),
  tt = {
      HIDE: "hide.bs.popover",
      HIDDEN: "hidden.bs.popover",
      SHOW: "show.bs.popover",
      SHOWN: "shown.bs.popover",
      INSERTED: "inserted.bs.popover",
      CLICK: "click.bs.popover",
      FOCUSIN: "focusin.bs.popover",
      FOCUSOUT: "focusout.bs.popover",
      MOUSEENTER: "mouseenter.bs.popover",
      MOUSELEAVE: "mouseleave.bs.popover"
  };

var et = function(t) {
  var n, i;

  function s() {
      return t.apply(this, arguments) || this;
  }

  i = t;
  (n = s).prototype = Object.create(i.prototype);
  n.prototype.constructor = n;
  n.__proto__ = i;

  var r = s.prototype;

  r.isWithContent = function() {
      return this.getTitle() || this._getContent();
  };

  r.addAttachmentClass = function(t) {
      e(this.getTipElement()).addClass("bs-popover-" + t);
  };

  r.getTipElement = function() {
      return this.tip = this.tip || e(this.config.template)[0], this.tip;
  };

  r.setContent = function() {
      var t = e(this.getTipElement());
      this.setElementContent(t.find(".popover-header"), this.getTitle());
      var n = this._getContent();

      if (typeof n === "function") {
          n = n.call(this.element);
      }

      this.setElementContent(t.find(".popover-body"), n);
      t.removeClass("fade show");
  };

  r._getContent = function() {
      return this.element.getAttribute("data-content") || this.config.content;
  };

  r._cleanTipClass = function() {
      var t = e(this.getTipElement());
      var classList = t.attr("class").match(J);
      if (classList !== null && classList.length > 0) {
          t.removeClass(classList.join(""));
      }
  };

  s._jQueryInterface = function(t) {
      return this.each(function() {
          var n = e(this).data("bs.popover");
          var options = typeof t === "object" ? t : null;

          if ((n || !/dispose|hide/.test(t)) && (!n && (n = new s(this, options), e(this).data("bs.popover", n)), typeof t === "string")) {
              if (typeof n[t] === "undefined") {
                  throw new TypeError('No method named "' + t + '"');
              }
              n[t]();
          }
      });
  };

  o(s, null, [
      { key: "VERSION", get: function() { return "4.5.2"; } },
      { key: "Default", get: function() { return G; } },
      { key: "NAME", get: function() { return Y; } },
      { key: "DATA_KEY", get: function() { return "bs.popover"; } },
      { key: "Event", get: function() { return tt; } },
      { key: "EVENT_KEY", get: function() { return ".bs.popover"; } },
      { key: "DefaultType", get: function() { return Z; } }
  ]);

  return s;
}(X);
e.fn[Y] = et._jQueryInterface;
e.fn[Y].Constructor = et;
e.fn[Y].noConflict = function() {
  return e.fn[Y] = $, et._jQueryInterface;
};

{ this._element = t; }

var n = t.prototype;

n.show = function() {
    var t = this;

    if (!(this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE &&
        e(this._element).hasClass("active") || e(this._element).hasClass("disabled"))) {
        
        var n, i, o = e(this._element).closest(".nav, .list-group")[0],
            s = a.getSelectorFromElement(this._element);

        if (o) {
            var r = "UL" === o.nodeName || "OL" === o.nodeName ? "> li > .active" : ".active";
            i = (i = e.makeArray(e(o).find(r)))[i.length - 1];
        }

        var l = e.Event("hide.bs.tab", { relatedTarget: this._element }),
            c = e.Event("show.bs.tab", { relatedTarget: i });

        if (i && e(i).trigger(l), e(this._element).trigger(c), 
            !c.isDefaultPrevented() && !l.isDefaultPrevented()) {
            
            if (s) n = document.querySelector(s);
            this._activate(this._element, o);

            var h = function() {
                var n = e.Event("hidden.bs.tab", { relatedTarget: t._element }),
                    o = e.Event("shown.bs.tab", { relatedTarget: i });
                e(i).trigger(n);
                e(t._element).trigger(o);
            };

            n ? this._activate(n, n.parentNode, h) : h();
        }
    }
};

n.dispose = function() {
    e.removeData(this._element, "bs.tab");
    this._element = null;
};

n._activate = function(t, n, i) {
    var o = this,
        s = (!n || "UL" !== n.nodeName && "OL" !== n.nodeName ?
            e(n).children(".active") : e(n).find("> li > .active"))[0],
        r = i && s && e(s).hasClass("fade"),
        l = function() { return o._transitionComplete(t, s, i); };

    if (s && r) {
        var c = a.getTransitionDurationFromElement(s);
        e(s).removeClass("show").one(a.TRANSITION_END, l).emulateTransitionEnd(c);
    } else {
        l();
    }
};

n._transitionComplete = function(t, n, i) {
    if (n) {
        e(n).removeClass("active");
        var o = e(n.parentNode).find("> .dropdown-menu .active")[0];
        if (o) e(o).removeClass("active");
        if ("tab" === n.getAttribute("role")) n.setAttribute("aria-selected", !1);
    }

    e(t).addClass("active");
    if ("tab" === t.getAttribute("role")) t.setAttribute("aria-selected", !0);
    a.reflow(t);

    if (t.classList.contains("fade")) t.classList.add("show");
    if (t.parentNode && e(t.parentNode).hasClass("dropdown-menu")) {
        var s = e(t).closest(".dropdown")[0];
        if (s) {
            var r = [].slice.call(s.querySelectorAll(".dropdown-toggle"));
            e(r).addClass("active");
        }
        t.setAttribute("aria-expanded", !0);
    }
    
    i && i();
};

t._jQueryInterface = function(n) {
    return this.each(function() {
        var i = e(this),
            o = i.data("bs.tab");
        
        if (!o) {
            o = new t(this);
            i.data("bs.tab", o);
        }

        if (typeof n === "string") {
            if (typeof o[n] === "undefined") {
                throw new TypeError('No method named "' + n + '"');
            }
            o[n]();
        }
    });
};

o(t, null, [{
    key: "VERSION",
    get: function() { return "4.5.2"; }
}]);

t();

e(document).on("click.bs.tab.data-api", 
    '[data-toggle="tab"], [data-toggle="pill"], [data-toggle="list"]', 
    function(t) {
        t.preventDefault();
        lt._jQueryInterface.call(e(this), "show");
    }
);

e.fn.tab = lt._jQueryInterface;
e.fn.tab.Constructor = lt;
e.fn.tab.noConflict = function() {
    return e.fn.tab = at, lt._jQueryInterface;
};

var ct = e.fn.toast,
    ht = {
        animation: "boolean",
        autohide: "boolean",
        delay: "number"
    },
    ut = {
        animation: !0,
        autohide: !0,
        delay: 500
    };

dt = function() {
    function t(t, e) {
        this._element = t;
        this._config = this._getConfig(e);
        this._timeout = null;
        this._setListeners();
    }

    var n = t.prototype;

    n.show = function() {
        var t = this,
            n = e.Event("show.bs.toast");

        if (e(this._element).trigger(n), !n.isDefaultPrevented()) {
            this._clearTimeout();
            this._config.animation && this._element.classList.add("fade");

            var i = function() {
                t._element.classList.remove("showing");
                t._element.classList.add("show");
                e(t._element).trigger("shown.bs.toast");
                t._config.autohide && (t._timeout = setTimeout(function() { t.hide(); }, t._config.delay));
            };

            if (this._element.classList.remove("hide"), a.reflow(this._element), 
                this._element.classList.add("showing"), this._config.animation) {
                
                var o = a.getTransitionDurationFromElement(this._element);
                e(this._element).one(a.TRANSITION_END, i).emulateTransitionEnd(o);
            } else {
                i();
            }
        }
    };

    n.hide = function() {
        if (this._element.classList.contains("show")) {
            var t = e.Event("hide.bs.toast");
            e(this._element).trigger(t);
            if (!t.isDefaultPrevented()) this._close();
        }
    };

    n.dispose = function() {
        this._clearTimeout();
        this._element.classList.contains("show") && this._element.classList.remove("show");
        e(this._element).off("click.dismiss.bs.toast");
        e.removeData(this._element, "bs.toast");
        this._element = null;
        this._config = null;
    };

    n._getConfig = function(t) {
        return t = s({}, ut, e(this._element).data(), "object" == typeof t && t ? t : {}),
            a.typeCheckConfig("toast", t, this.constructor.DefaultType), 
            t;
    };

    n._setListeners = function() {
        var t = this;
        e(this._element).on("click.dismiss.bs.toast", '[data-dismiss="toast"]', function() {
            return t.hide();
        });
    };

    n._close = function() {
        var t = this,
            n = function() {
                t._element.classList.add("hide");
                e(t._element).trigger("hidden.bs.toast");
            };

        if (this._element.classList.remove("show"), this._config.animation) {
            var i = a.getTransitionDurationFromElement(this._element);
            e(this._element).one(a.TRANSITION_END, n).emulateTransitionEnd(i);
        } else {
            n();
        }
    };

    n._clearTimeout = function() {
        clearTimeout(this._timeout);
        this._timeout = null;
    };

    t._jQueryInterface = function(n) {
        return this.each(function() {
            var i = e(this),
                o = i.data("bs.toast");

            if (!o) {
                o = new t(this, "object" == typeof n && n);
                i.data("bs.toast", o);
            }

            if (typeof n === "string") {
                if (typeof o[n] === "undefined") {
                    throw new TypeError('No method named "' + n + '"');
                }
                o[n](this);
            }
        });
    };

    o(t, null, [{
        key: "VERSION",
        get: function() { return "4.5.2"; }
    }, {
        key: "DefaultType",
        get: function() { return ht; }
    }, {
        key: "Default",
        get: function() { return ut; }
    }]);

    return t;
}();

e.fn.toast = dt._jQueryInterface;
e.fn.toast.Constructor = dt;
e.fn.toast.noConflict = function() {
    return e.fn.toast = ct, dt._jQueryInterface;
};

t.Alert = h;
t.Button = d;
t.Carousel = b;
t.Collapse = C;
t.Dropdown = I;
t.Modal = P;
t.Popover = et;
t.Scrollspy = rt;
t.Tab = lt;
t.Toast = dt;
t.Tooltip = X;
t.Util = a;

Object.defineProperty(t, "__esModule", { value: !0 })}));